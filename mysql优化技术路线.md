# mysql优化技术路线
### 1. 合理的表设计(符合三范式)
* 1NF：属性列具有原子性(关系型数据库自动满足1NF)
* 2NF：表中记录唯一性(主键合理性)
* 3NF：表之间不要有冗余数据，可以合理使用外键
* 反3NF：为了提高运行效率，适当保留冗余数据，比如QQ某相册浏览次数==相册内所有相片浏览次数总和

### 2. 添加适当的索引(普通索引、主键索引、唯一索引、全文索引)
(1).最左前缀原则
* 在B+树结构索引中，索引是有序的，查找索引时，可以快速定位到匹配前缀最左边，然后直接向右遍历查找相同前缀项，最左前缀匹配主要用于联合索引。
* 哈希索引：哈希表把索引字段映射成对应的哈希码存放在对应的位置，虽然哈希索引查询效率很高，但是当需要进行模糊查找时，显然哈希表这种结构不支持模糊查询。 正因为B+树支持最左前缀原则更适合做数据库索引，而哈希索引一般是数据库内部用来做一些查询缓存，从而提高查询速度。

(2).主键索引
* 主键索引是一种特殊的唯一非空索引，创建表时如果设定某列为主键，则该列就是主键索引；
* 如果创建表时没有指定主键索引(没有设定主键)，可以通过修改表方式添加主键：ALTER TABLE tbl_xxx ADD PRIMARY KEY (id) 

(3).聚簇索引与非聚簇索引

聚簇索引并非真正的索引，指的是将表的主键构造一棵B+树，叶子节点直接存放行记录数据；而非聚簇索引的索引与数据是分开储存的
对于mysql，MyISAM的索引与InnoDB的索引的主要区别主要如下：
   
MyISAM的索引：
<br/>①. MyISAM的索引与数据分开存储(即有连续聚集的区域单独存储行记录)，为非聚簇索引;
<br/>②. MyISAM的索引的叶子存储索引列和数据记录行指针; 所以MyISAM的主键索引与普通索引没有本质差异;
<br/>③. 主键索引与普通索引是两棵独立的索引B+树，通过索引列查找时，先定位到B+树的叶子节点，再通过指针定位到行记录。
   
InnoDB的索引:
<br/>①. InnoDB的主键索引与行记录是存储在一起的，为聚集索引：
<br/>②. InnoDB的表必须要有聚集索引：如果表定义了PK，则PK就是聚集索引；如果表没有定义PK，则第一个非空unique列是聚集索引；否则，InnoDB会创建一个隐藏的row-id作为聚集索引；
<br/>③. 聚集索引有且只有一个，因为数据行在物理磁盘上只能有一份聚集存储；且聚集索引和数据行统一存储；
<br/>④. 主键索引的叶子节点(内部节点只存储主键)，存储主键和对应行记录数据(而不是指针)；
<br/>⑤. InnoDB普通索引可以有多个，普通索引与聚集索引不同：普通索引的叶子节点存储索引列和主键列，所以普通索引通常需要二次回表(内部自适应哈希索引能减少二次回表的重复操作)；
<br/>⑥. InnoDB主键索引叶子节点直接存储了数据行，数据移动效率比较慢，所以InnoDB主键尽量使用自增整型，如果使用无规律数据作为主键，容易产生页分裂，导致更新、查询数据库操作效率低
<br/>⑦. InnoDB主键和数据列不宜使用过长字段类型，由于InnoDB使用聚簇索引，过长的字段类型容易产生页分裂，导致查询主键索引时需要跨越很多分页，大大降低查询速度，这种情况用MyISAM引擎更合适

(4).唯一索引

当表的某一列被指定为unique约束时，这列就是一个唯一索引；唯一索引可以为NULL，也可以有多个NULL，但是不能有多个''
还可以在创建表后通过指令创建唯一索引：create unique index 索引名  on 表名 (列, ...);

(5).联合索引(多列索引)

联合索引的每个节点有多个键值，按从左至右优先排序，创建联合索引时，应将选择性最高的列放在索引最前面，
查询时索引需要遵循最左前缀原则，即按从左到右使用索引，中间不能间断，否则间断处以及后面索引无法发挥作用
示例：索引(a,b,c)，where b = 2(不能使用)、where a=1 and c = 3(a可以使用，c不能使用)、where a=1 and b>2 and c=3(a和b能使用,c不能使用)

(6).覆盖索引
   
覆盖索引又称索引覆盖，指的是查询的列是索引的子集，比如查询联合索引中某一列，因此查询的时候不需要访问数据表。

(7).索引缺点：占用额外磁盘、维护索引会导致更新数据库类操作变慢

(8).适合添加索引场景
* 经常作为查询条件的字段
* 唯一性太差字段，值太少，比如性别、状态不适合建索引
* 更新非常频繁字段(比如登录状态)不适合建索引

(9).其他
* 利用联合索引的有序性，避免对查询结果再进行filesort

### 3. 分表、分库、表分区
(1)分表：分为表数据拆分和表结构拆分
* 水平分割：表数据记录达到千万级别时最常见的优化操作，将表数据分到多张表分别存储，减少单张表数据记录数
* 垂直分割：将表中字段很长属性列拆分到另一个表、将文件和图片存到独立服务器，当前表仅仅存储url

(2)分库：采用分布式微服务架构，对每一个服务部署一组服务器，每当服务器负载超负荷，扩建一台新服存储新的数据

(3)表分区：当数据量很大时，采用partition表分区可以让表数据和索引分块存放，可以有效降低索引B+树层数，提高查询效率


### 4. 充分利用内存缓存：减少读取数据的IO操作，缺点：数据一致性同步容易出问题

### 5. 主从复制和读写分离
为了防止服务器宕机，通常数据库都有做主从复制集群技术；当数据库压力很大时，为了减轻主库压力，通常会考虑读写分离技术：
主库用于处理更新数据库类操作; 将查询类数据库操作，通过负载均衡，分流到各个从库

### 6. 存储过程：省去DBMS编译过程，缺点：移植性不好

### 7. mysql配置(my.ini)优化
* 调整最大连接并发数：max_connections至1000-2000
* 调整缓存大小：
	<br/>①. MyISAM调整key_buffer_size; 
	<br/>②. InnoDB调整innodb_additional_mem_pool_size = 64M;　innodb_buffer_pool_size =1G


### 8. mysql服务器硬件升级

### 9. 清理、转移历史数据，对MyISAM定期进行碎片整理(optimize table tbl_xxx)
mysql经常出现一张表删除了许多数据后，但这张表的数据文件和索引文件却没有变小；
这是因为mysql在删除数据(特别是有Text和BLOB)时，会留下许多数据空洞，这些空洞会占据原来数据的空间，
这些空洞在以后插入数据时候可能会被再度利用起来，也有可能一直存在。
这种空洞不仅额外增加了存储代价，同时也会因为数据碎片化降低表的扫描效率。


# sql语句优化一般步骤
问题：如何从一个大项目中，迅速定位慢查询
### 1. 了解mysql数据库一些运行状态信息
①. 查看mysql服务器状态信息：show [session|global] status, 
默认session级别，用来查询当前连接会话统计结果，退出当前连接就失效；
global是全局的，用来查询数据库从上次启动至今统计结果，重启数据库或者关闭数据库失效；
<br/>②. 查询mysql本次启动后运行时间：show status like 'uptime'
<br/>③. 查看试图连接到数据库(不管是否连接成功)的连接数：show status like 'connections'
<br/>④. 查看线程缓存内的线程的数量：show status like 'threads_cached'
<br/>⑤. 查看慢查询次数：show status like 'slow_queries'
<br/>⑥. 查看select、insert、update等语句的执行数，从而了解项目业务类型：show status like 'com_select'; show status like 'com_insert'; show status like 'com_delete'
<br/>⑦. 查看索引使用情况：show status like 'Handler_read%'(Handler_read_key越高表示使用索引查询次数越高，	handler_read_rnd_next越高说明索引查询使用低效)

### 2. 定位慢查询(慢查询日志会记录每一条查询时间超过阈值的sql语句)
①.开启慢查询日志，默认关闭： set global slow_query_log = on
<br/>②. 查询当前慢查询时间：show variables like 'long_query_time'
<br/>③. 设置慢查询时间阀值，默认10s：set global long_query_time = 1(0.1s-1s)
<br/>④. 查询慢查询日志路径：show global variables like 'datadir'
<br/>⑤. 查询慢查询日志的文件名：show global variables like 'slow_query_log_file'

### 3. 使用explain分析sql语句执行过程, 分析sql语句是否规范，常见错误：
使用联合索引时不遵循最左前缀匹配、不规范模糊查询('%xxx'、'_xxx')、or条件查询包含非索引列


### 4. 批量导入数据的时候，先关闭索引和唯一性校验，以防止在导致数据过程中创建索引和校验唯一性，降低速度
关闭索引：alter table tbl_name disable keys;
关闭唯一性校验：set unique_checks=0;

### 5. 使用Group By分组查询时，分组后会默认对分组进行排序；如果不需要排序，可以加上order by null，免去排序
Group BY xxx Order By null

### 6. 大数据量分页优化
分页查询：select xxx from tbl_xxx limit (N-1) * perpage, N;
当数据量非常大时，该查询会非常缓慢，常见有下列解决方法：

①. 不允许翻太多页，一般可以翻几十页

②. 利用索引：select id, name from tbl_xxx where id > (N-1) * perpage limit N;

②. 延迟关联技巧：当查询数据偏移量大、不限制用户分页最大数、还需要用offset精确查询时，可以先只查索引，不查数据;
即先用索引查询作为子查询得到相应id，再用id去查具体数据条目，比如：
select id,name from tbl_user limit 5000000,10;
select tbl_user.id,name from tbl_user inner join(select id from tbl_user limit 5000000, 10) as tmp on tbl_user.id=tmp.id


## 子查询陷阱
①. In子查询陷阱：类似select xxx where x in (select xxx),该查询会进行全表扫描，将每一条查询结果与子查询进行比较,当数据量很大时，全表扫描非常耗时
优化方案：a.拆解查询语句,每次使用单表查询,先得到子查询结果;b.使用连接查询




















