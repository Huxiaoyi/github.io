# mysql事务
mysql事务主要用于处理操作量大、复杂度高、高并发安全性要求很高的数据；比如员工离职时需要清理员工所有相关的个人、部门等信息，比如银行系统对支付、转账，尤其涉及并发时的安全性要求很高等。

## 1. mysql事务相关概念
* 事务用于维护数据库的完整性，保证批量sql操作要么全部执行，要么全部不执行
* MyISAM不支持事务，Innodb支持事务
* 事务用来管理insert,update,delete类型语句
* 事务4个特性：
<br/>①. 原子性：一个事务中所有操作，要么全部执行，要么全部不执行
<br/>②. 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏；比如A向B转账，不可能A扣了钱，B却没收到
<br/>③. 隔离性：事务进行过程中，其他事务看不到此事务的任何效果，其中事务隔离分为四个级别：读未提交、读提交、可重复读和串行化
<br/>④. 持久性：事务处理结束后，对数据的修改就是永久的，即便系统出故障、宕机也不会丢失

## 2. 事务隔离级别
事务隔离级别分为四个等级，从上到下依次增强：
* 读未提交：一个事务可以读取到其他还尚未提交的事务
* 读提交：一个事务执行过程中，读不到另一个进行中的事务，但该事务提交后可以读取到
* 可重复读：事务之间各自独立，读取不到彼此之间未提交和已提交的内容，该级别为默认的隔离级别
* 串行化：所有语句按先后之分，一句一句执行，效率太低

## 3. 事务的并发问题
* 脏读：事务A读取了事务B更新但还尚未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据
* 不可重复读：事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时结果不一致
* 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

小结：不可重复读和幻读很容易混淆，不可重复读侧重于修改操作，幻读侧重于新增或删除操作；
解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

## 4. 事务隔离级别带来的并发问题
|事务隔离级别      | 脏读 | 不可重复读 | 幻读|
|:-----------------|:----:|:----------:|-----|
|read uncommitted  |  是  |      是	   |  是 |
|read committed    |  否  |      是	   |  是 |
|repeatable read   |  否  |      否	   |  是 |
|serializable	   |  否  |      否	   |  否 |
```
修改配置文件设置数据库隔离级别
[mysqld]
transaction-isolation = [ READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE ]
```

## 5. 事务并发控制：乐观锁和悲观锁
事务的并发是数据库访问操作经常遇到的问题，比如有2个并发操作修改同一行数据的某一个字段，如果不进行加锁操作，则非常容易出现事务覆盖问题，导致数据的不一致性。数据库锁就是为了解决事务隔离级别过程中遇到的并发问题。

### (1). 悲观锁
顾名思义，就是很悲观，是我们通常说的数据库锁机制；悲观锁对数据被的修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁、表锁,不论是读写锁都是悲观锁。

在事务中，通过select...for update的方式实现悲观锁(其他事务依然可使用普通查询语句，但不能用select...for update)，此外，要使用悲观锁，必须先关闭mysql数据库的自动提交属性：set autocommit=0;　
悲观锁按照使用性质可以分为：
共享锁S(也称为读锁，多个事务可以同时读)、排它锁X(也称为写锁)、更新锁U。
更新锁用来预定要对此对象施加写锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要用来防止死锁。

### (2). 乐观锁
顾名思义，就是很乐观，认为数据在被修改的时候不会出现并发问题，所以不加锁，但是在更新的时候会去判断在此期间数据有没有被修改，这需要用户自己去实现。乐观锁实现的方式：

①. 版本号version：需要给数据表新增version字段，每次更新把version字段加1，读取数据的时候把version读出来，更新的时候比较version值，如果version值没有发生变化，可以直接更新；如果现在的version值之前读取的值大，说明有其他事务更新了该数据，并提升了版本号，这时候会得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始。

②. 时间戳(timestamp)：和版本号方式类似，通过时间戳来判断，注意时间戳要使用数据库服务器的时间戳，而不是业务系统的时间

③. 待更新字段/所有字段：和版本号方式相似，只是不增加额外表字段，直接使用有效数据字段做版本控制信息，该方式有坑

小结：

①. 悲观锁通过最大程度的独占性保证数据一致性，但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 此外，InnoDB默认是行级锁，行级锁都是基于索引的，如果一条SQL语句用不到索引，是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要慎重。

②. 乐观锁并未真正加锁，仅仅是面对高并发问题提出的一种思想策略，可以用于事务中，也可以用于日常数据库操作中；优点是效率高，缺点是锁的粒度不好掌控，一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。
















